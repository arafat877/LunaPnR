
#include "common/logging.h"
#include "common/visitor.h"

#include "celllib/celllib.h"
#include "netlist/net.h"
#include "netlist/instance.h"
#include "lunapnr_version.h"

#include "verilogwriter.h"

using namespace LunaCore::Verilog;

static std::string escapeVerilogName(const std::string &name)
{
    auto iter = name.find_first_of('[');
    if (iter != std::string::npos)
    {
        return "\\" + name + " ";
    }

    return name;
}

bool Writer::write(std::ostream &os, const ChipDB::Module *mod)
{
    if (mod == nullptr)
    {
        return false;
    }

    if (!mod->isModule())
    {
        return false;
    }

    os << "/* netlist generated by " << LunaCore::lunaversion << " */ \n";

    if (!writeModuleDefinition(os, mod))
    {
        return false;
    }

    for(auto const* netPtr : mod->m_netlist.m_nets)
    {
        if (!netPtr->m_isPortNet)
        {
            os << "wire " << escapeVerilogName(netPtr->m_name) << ";\n";
        }
        else
        {
            auto const& pinInfo = mod->lookupPin(netPtr->m_name);
            
            if (pinInfo == nullptr)
            {
                doLog(LOG_ERROR,"Port net cannot be resolved to module pin!\n");
                return false;
            }

            switch(pinInfo->m_iotype)
            {
            case ChipDB::IOType::INPUT:
                os << "input ";
                break;
            case ChipDB::IOType::OUTPUT:
                os << "output ";
                break; 
            case ChipDB::IOType::IO:
                os << "inout ";
                break;
            default:
                doLog(LOG_ERROR, "Verilog writer: unsupported pin type %s\n", toString(pinInfo->m_iotype).c_str());
                return false;            
            }            
            os << escapeVerilogName(netPtr->m_name) << ";\n";
        }
    }

    os << "\n\n";

    if(!writeModuleInstances(os, mod))
    {
        return false;
    }

    os << "endmodule\n\n";

    return true;
}

bool Writer::writeModuleDefinition(std::ostream &os, const ChipDB::Module *mod)
{
    os << "module " << mod->m_name << "(\n\t";

    bool firstPort = true;
    for(auto const& pin : mod->m_pins)
    {
        if (!firstPort)
        {
            os << ",\n\t";
        }
        os << escapeVerilogName(pin.m_name);
        firstPort = false;
    }

    os << "\n);\n\n";
    return true;
}

namespace LunaCore::Verilog
{

    class ExportConstVisitor : public ChipDB::ConstVisitor
    {
    public:
        ExportConstVisitor(std::ostream &os) : m_os(os), m_ok(true) {}

        [[nodiscard]] bool isOk() const
        {
            return m_ok;
        }

        void visit(const ChipDB::InstanceBase *instance) override 
        {
            doLog(LOG_ERROR,"Verilog writer: cannot write InstanceBase to netlist\n");
            m_ok = false;
        };

        void visit(const ChipDB::Instance *instance) override
        {
            if (instance == nullptr)
            {
                m_ok = false;
                return;
            }

            if (instance->m_insType != ChipDB::Instance::INS_CELL)
            {
                m_ok = false;
                doLog(LOG_ERROR, "Verilog writer: expected a Cell instance but got %s\n", instance->m_name.c_str());
                return;
            }

            if (instance->cell() == nullptr)
            {
                // this is not a regular cell, might it be a __NETCON?
                // which must be translated to an assign statement
                if (instance->m_name == "__NETCON")
                {
                    auto inputNet  = instance->getConnectedNet(0);
                    auto outputNet = instance->getConnectedNet(1);
                    m_os << "assign " << escapeVerilogName(outputNet->m_name) << "=" << escapeVerilogName(inputNet->m_name) << ";\n";
                }
                else
                {
                    m_ok = false;
                    doLog(LOG_ERROR, "Verilog writer: can't write instance %s without a cell name!\n", instance->m_name.c_str());
                    return;
                }
                
            }
            else
            {
                m_os << instance->getArchetypeName() << " " << instance->m_name << " (";
                bool firstPin = true;
                for(ssize_t pinIndex=0; pinIndex < instance->getNumberOfPins(); pinIndex++)
                {
                    auto const* netPtr = instance->getConnectedNet(pinIndex);
                    auto const* pinInfoPtr = instance->getPinInfo(pinIndex);
                    if ((netPtr != nullptr) && (pinInfoPtr != nullptr))
                    {
                        if (!firstPin)
                        {
                            m_os << ",";
                        }

                        m_os << "\n  ." << escapeVerilogName(pinInfoPtr->m_name) << "(" << escapeVerilogName(netPtr->m_name) << ")";
                        firstPin = false;
                    }
                }

                if (!firstPin)
                {
                    m_os << "\n";
                }

                m_os << ");\n";
            }
        }
        
        void visit(const ChipDB::Cell *cell) override
        {
            doLog(LOG_ERROR,"Verilog writer: cannot write Cell to netlist\n");
            m_ok = false;
        }

        void visit(const ChipDB::Module  *module) override
        {
            doLog(LOG_ERROR,"Verilog writer: cannot write sub-module %s to netlist\n", module->m_name.c_str());
            m_ok = false;
        }

        void visit(const ChipDB::PinInstance *instance) override {};
        void visit(const ChipDB::PinInfo *pin) override {};
        void visit(const ChipDB::Netlist *nl) override {};
        void visit(const ChipDB::Net *net) override {};
        void visit(const ChipDB::LayerInfo *layer) override {};

    protected:
        bool m_ok;
        std::ostream &m_os;
    };

};

bool Writer::writeModuleInstances(std::ostream &os, const ChipDB::Module *mod)
{
    ExportConstVisitor v(os);

    for(auto const* ins : mod->m_netlist.m_instances)
    {
        ins->accept(&v);
        if (!v.isOk())
        {
            return false;
        }
    }

    return true;
}
