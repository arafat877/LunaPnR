// SPDX-FileCopyrightText: 2021-2022 Niels Moseley <asicsforthemasses@gmail.com>
//
// SPDX-License-Identifier: GPL-3.0-only

#include <fstream>
#include <chrono>

#include "common/logging.h"
#include "design/design.h"
#include "spefwriter.h"

static std::string quoted(const std::string &str)
{
    return "\"" + str + "\"";
}

bool LunaCore::SPEF::write(std::ostream &os, const std::shared_ptr<ChipDB::Module> module)
{
    if (!module)
    {
        Logging::doLog(Logging::LogType::ERROR, "SPEF writer: module is nullptr!\n");
        return false;
    }

    auto currentTime = std::chrono::system_clock::now();
    auto currentTime_t = std::chrono::system_clock::to_time_t(currentTime);
    auto timeString = std::string(std::ctime(&currentTime_t));

    // remove end of lines from the time string
    timeString.erase(std::remove(timeString.begin(), timeString.end(), '\n'), timeString.cend());

    os << "*SPEF        " << quoted("IEEE 1481-2009") << "\n";
    os << "*DESIGN      " << quoted(module->name()) << "\n";
    os << "*DATE        " << quoted(timeString) << "\n";
    os << "*VENDOR      " << quoted(LUNAVERSIONSTRING) << "\n";
    os << "*PROGRAM     " << quoted(LUNAVERSIONSTRING) << "\n";
    os << "*VERSION     " << quoted("1.1.0") << "\n";
    os << "*DESIGN_FLOW " << quoted("EXTERNAL_LOADS") << "\n";
    os << "*DIVIDER /\n";
    os << "*DELIMITER :\n";
    os << "*BUS_DELIMITER [ ]\n";
    os << "*T_UNIT 1 NS\n";
    os << "*C_UNIT 1 PF\n";
    os << "*R_UNIT 1 OHM\n";
    os << "*L_UNIT 1 HENRY\n";
    os << "\n";

    const float FaradToPicofarad = 1.0e12f;

    // FIXME: do a much better job
    // assume all pins on instances are in the center.. 

    auto const &nets = module->m_netlist->m_nets;
    auto const &instances = module->m_netlist->m_instances;

    os << "*PORTS\n";
    for(auto const portPins : module->m_pins)
    {
        os << portPins->name() << " ";
        switch(portPins->m_iotype)
        {
        case ChipDB::IOType::INPUT:
            os << "I\n";
            break;
        case ChipDB::IOType::OUTPUT:
            os << "O\n";
            break;          
        case ChipDB::IOType::OUTPUT_TRI:
        case ChipDB::IOType::IO:
        case ChipDB::IOType::ANALOG:
            os << "B\n";
            break;
        case ChipDB::IOType::POWER:
            break;
        case ChipDB::IOType::GROUND:
            break;
        case ChipDB::IOType::UNKNOWN:
            break;            
        }
    }
    
    os << "\n";

    for(auto const netKeyPair : nets)
    {
        os << "*D_NET " << netKeyPair->name() << " 0.0\n";

        // write the connections
        bool portNet = netKeyPair->m_isPortNet;
        for(auto const& conn : *netKeyPair)
        {
            auto const ins = instances.at(conn.m_instanceKey);
            auto const pin = ins->getPin(conn.m_pinKey);
            
            if ((portNet) && (ins->getArchetypeName() == std::string("__PIN")))
            {
                os << "*P " << ins->name()<< " ";
                // note direction of port pins is reversed!
                if (pin.m_pinInfo->isInput())
                {
                    os << "O *C " << ins->m_pos.m_x/1000.0 << " " << ins->m_pos.m_y/1000.0 << "\n";
                }
                else
                {
                    os << "I *C " << ins->m_pos.m_x/1000.0 << " " << ins->m_pos.m_y/1000.0 << "\n";
                }
            }
            else
            {
                os << "*I " << ins->name() << ":" << pin.name() << " ";
                if (pin.m_pinInfo->isInput())
                {
                    os << "I *C " << ins->m_pos.m_x/1000.0 << " " << ins->m_pos.m_y/1000.0 << " L " << pin.m_pinInfo->m_cap*FaradToPicofarad << "\n";
                }
                else
                {
                    os << "O *C " << ins->m_pos.m_x/1000.0 << " " << ins->m_pos.m_y/1000.0 << " L " << pin.m_pinInfo->m_cap*FaradToPicofarad << " ";
                    os << "*D " << ins->getArchetypeName() << "\n";
                }
            }
        }

        os << "*END\n\n";
    }

#if 0
    os << "# Routing positions to center of the cells. Generated by LunaPnR " LUNAVERSIONSTRING "\n";
    os << "# Format: <number of points> <point1 x> <point1 y> ... <pointN x> <pointN y> <newline>\n";

    for(auto const netKeyPair : netlist->m_nets)
    {
        // write number of points in the net
        os << netKeyPair->numberOfConnections() << " ";

        // write locations of all the terminals
        for(auto netConnect : *netKeyPair)
        {
            auto ins = netlist->lookupInstance(netConnect.m_instanceKey);
            if (!ins->isPlaced())
            {
                Logging::doLog(Logging::LogType::WARNING,"TXT writer: instance %s has no location / is not placed.!\n", ins->name().c_str());
                return false;
            }

            os << ins->m_pos.m_x << " " << ins->m_pos.m_y << "  ";
        }
        os << "\n";
    }
#endif
    return true;
}

bool LunaCore::SPEF::write(const std::string &filename, const std::shared_ptr<ChipDB::Module> module)
{
    std::ofstream ofile(filename);
    if (!ofile.good())
    {
        Logging::doLog(Logging::LogType::ERROR,"SPEF writer: cannot open file %s for writing!\n", filename.c_str());
        return false;
    }

    return LunaCore::SPEF::write(ofile, module);
}
