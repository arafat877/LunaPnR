// SPDX-FileCopyrightText: 2021-2023 Niels Moseley <asicsforthemasses@gmail.com>
//
// SPDX-License-Identifier: GPL-3.0-only

#include <iostream>
#include <sstream>

#include <tomlpp.hpp>
#include <replace.hpp>

const std::string enumTemplate =
{R"(
class ###NAME### : public EnumTag
{
public:
    constexpr static int UNDEFINED = -1;
###VALUES###
###ARRAY###

    std::string toString() const noexcept               
    {                                                   
        if ((m_value < 0) || (m_value >= m_names.size()))
        {
            return "UNDEFINED";
        }

        return m_names.at(m_value);
    }

    void fromString(const std::string &optName)
    {
        int index = 0;
        for(auto const& name : m_names)
        {
            if (optName == name) 
            {
                m_value = index;
                return;
            }
            
            index++;
        }
    }

    constexpr void operator=(int value) noexcept
    {
        m_value = value;
    }

    constexpr void operator=(const std::string &value) noexcept
    {
        fromString(value);
    }

    bool operator==(int value) const noexcept
    {
        return m_value == value;
    }
                                                        
    bool operator==(const ###NAME### &e) const noexcept
    {                                                   
        return m_value == e.m_value;
    }

    bool operator==(const std::string &value) const noexcept
    {                                                           
        return m_value.toString() == m_value;
    }     

    constexpr int value() const noexcept
    {
        return m_value;
    }

    auto begin() const
    {
        return m_names.begin();
    }

    auto end() const
    {
        return m_names.end();
    }

protected:
    int m_value{UNDEFINED};
};

std::ostream& operator<<(std::ostream& os, const ###NAME### &e)
{
    os << e.toString();
    return os;
};

)"
};

int main(int argc, const char *argv[])
{
    if (argc < 3)
    {
        std::cerr << "Usage: " << argv[0] << " <infile.toml> <outfile.hpp>\n";
        return EXIT_FAILURE;
    }

    std::cout << "---------------------------------\n";
    std::cout << "  EnumGen version 1.0\n";
    std::cout << "---------------------------------\n";

    toml::table tbl;

    try
    {
        tbl = toml::parse_file(argv[1]);
    }
    catch (const toml::parse_error& err)
    {
        std::cerr << "Parsing failed:\n" << err << "\n";
        return EXIT_FAILURE;
    }

    std::string result;

    // write header
    result.append("// SPDX-FileCopyrightText: 2021-2023 Niels Moseley <asicsforthemasses@gmail.com>\n");
    result.append("// SPDX-License-Identifier: GPL-3.0-only\n");
    result.append("// Auto generated by enumgen - part of LunaPnR\n\n");
    result.append("#pragma once\n");
    result.append("#include <string>\n");
    result.append("#include <iostream>\n");    
    result.append("#include <array>\n\n");

    result.append("#ifndef DEF_ENUMTAG\n");
    result.append("\t#define DEF_ENUMTAG\n");
    result.append("\tstruct EnumTag{};\n");
    result.append("#endif\n\n");

    auto enums = tbl["enums"].as_table();
    for (auto [key, value] : *enums) 
    {        
        std::cout << "  Generating enum: " << key << "\n";

        std::string valueStr;
        std::string arrayStr = "\tconst std::array<const char*, ###COUNT###> m_names = {\n";

        int counter = 0;
        auto items = value.as_array();
        if (items != nullptr)
        {
            for(auto const& item : *items)
            {
                auto str = item.as_string();
                if (str != nullptr)
                {
                    auto itemName = str->get();
                    std::stringstream ss;
                    ss << "\tconstexpr static int " << itemName << " = " << counter << ";\n";
                    valueStr.append(ss.str());
                    
                    ss.str("");
                    if (counter != 0)
                    {
                        ss << ",\n";
                    }
                    ss << "\t\t\"" << itemName << "\"";
                    arrayStr.append(ss.str());

                    counter++;
                }
            }
            arrayStr.append("};\n");
        }

        std::string tmp = enumTemplate;
        tmp = replace(tmp, "###NAME###", key.str());
        tmp = replace(tmp, "###ARRAY###", arrayStr);
        tmp = replace(tmp, "###VALUES###", valueStr);
        tmp = replace(tmp, "###COUNT###", std::to_string(counter));
        result.append(tmp);
    }

    std::ofstream ofile(argv[2]);
    if (!ofile)
    {
        std::cerr << "Cannot open " << argv[2] << " for writing!\n";
        return EXIT_FAILURE;
    }

    ofile << result;

    return EXIT_SUCCESS;
}
